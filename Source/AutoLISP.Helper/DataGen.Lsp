(defun C:AnnPt(/ i iLen sset, ent ZVal)
	(princ "\nSelect Objects")
	(setq sset (ssget))
	(if(/= sset nil)
		(setq iLen (sslength sset))
		(setq iLen 0)
	)
	(setq  i 0)
	(while (< i iLen)
		(setq ent (ssname sset i))
		(if(/= ent nil)
			(progn
				(setq ent (entget ent))
				(if(= (cdr (assoc 0 ent)) "POINT")
					(progn
						(setq ZVal (nth 2 (cdr (assoc 10 ent)))
							  ZVal (rtos ZVal 2)
						)
						(TEXTMID (polar (cdr (assoc 10 ent)) -90.0 (* (getvar "TEXTSIZE") 1.0)) ZVal 0 (* (getvar "TEXTSIZE") 1.0) "Annotate_Point")
					)
				)
			)
		)
		(setq  i (+ i 1))
	)
)
(defun C:GENData(/ strFile hFile listVals strLine)
    (setq strFile (getfiled "" "E:\\Contour\\Out.Dat" "" 2))
	(setq hFile (open strFile "r") strLine "")
	(if (/= hFile nil)
		(progn
			(while(/= strLine  nil)
				(setq strLine (read-line hFile))
				(if(/= strLine nil)
					(progn
						(setq listVals (XtractAllWords strLine)
							  listVals (WordListToRealList listVals)
						)
						(POINT listVals "POINT")
					)
				)
			)
		)
	)
	(if (/= hFile nil)
		(close hFile)
	)
)
;;
;;From a Line Data extracts All Words of a Line &
;;Returns the Words in a list
;;Status OK
;;
(defun XtractAllWords (strLineData / retListOfStr i iLoopLim char bRecordChar StrWord )
  (if (= strLineData nil)
    (progn
       (princ "\nError Occured in Func. (GetFirstWord)\nParameter Received is nil\n")
       (princ "\nTrace in Func. GetFirstWord Arg = ")(princ "\n") (princ strLineData) (princ "\n")
     )
  )
  (setq retListOfStr (list ()))
  (setq i 1 iLoopLim (strlen strLineData) bRecordChar 0)
  (while (< i (+ iLoopLim 1))
     (setq char (substr strLineData i 1))
     (if (or (= char " ") (= char "\n") (= char "\t"))
        (progn
           (if (= bRecordChar 1)
             (progn
              (setq retListOfStr (append retListOfStr (list StrWord)))
              (setq StrWord "" bRecordChar 0)
             )
           )
        )
        (progn
           (if (= bRecordChar 0) (setq bRecordChar 1 StrWord ""))
           (setq StrWord (strcat StrWord char))
        )
     )
     (setq i (+ i 1))
  );while
  (if (= bRecordChar 1) (setq retListOfStr (append retListOfStr (list StrWord))))
  (setq retListOfStr (cdr retListOfStr));; Return
)
;;
;;Converts a List of strings to a list of real
;;Returns the real Nos in a list
;;Status OK
;;
(defun WordListToRealList (listOfWords / retListOfReals i iLoopLim)
  (setq retListOfReals (list ()))
  (setq i 0 iLoopLim (length listOfWords))
  (while (< i iLoopLim)
     (setq retListOfReals (append retListOfReals (list (atof (nth i listOfWords)))))
     (setq i (+ i 1))
  );while
  (setq retListOfReals (cdr retListOfReals));; Return
)
(defun MakeOffsetElevList (OffElevDataStr / StrOfOffElev i iLoopLim listOfOffElev )
  (setq listTemp (XtractAllWords OffElevDataStr))
  ;; Remove First two columns having only 0's & 3rd having Chainage
  (setq listTemp (cdr (cdr (cdr listTemp))))
  (setq listTemp (WordListToRealList listTemp))
)

(defun DebugPrintList (strCaption strList / i iLoopLim)
	(setq i 0 iLoopLim (length strList))
	(while (< i iLoopLim)
		(princ (strcat "\n" strCaption "Start=============\n"))
		(princ (nth i strList))
        (princ (strcat "\n" strCaption "End============\n"))
		(if (= DEBUG T) (getstring "\nPaused :"))
		(setq i (+ i 1))
	)
)
(defun IsStrNumeric (strArg / i iLoopLim chChar bContinue bDotFound)
	(setq i 1  iLoopLim (strlen strArg) bContinue 1 bDotFound 0)
	(while (and (<= i iLoopLim) (= bContinue 1))
		(setq chChar (ascii (substr strArg i 1)))
		(if (or (and (<= chChar 57) (>= chChar 48)) (= chChar 46))
			(if (= chChar 46)
			    (if (= bDotFound 1)
					(setq bDotFound 2 bContinue 0)
					(setq bDotFound 1 bContinue 1)
			    )
			)
			(setq bContinue 0)
		)
		(setq i (+ i 1))
	)
    (if (= bContinue 0) (setq ret nil) (setq ret T)) ; return
    (setq ret ret) ; return
)
;; Verifies wheather a string is like "10.00+12" or not
;;
(defun IsStrStation (strArg / i iLoopLim strPre strPost bGotThePlusSign chChar ret)
	(setq i 1  iLoopLim (strlen strArg) strPre "" strPost "")
	(setq bGotThePlusSign 0)
	(while (<= i iLoopLim)
		(setq chChar (substr strArg i 1))
		(if (= chChar "+") (setq bGotThePlusSign 1))
		(if (= bGotThePlusSign 0)
		   (setq strPre (strcat strPre chChar))
		   (if (not (= chChar "+")) (setq strPost (strcat strPost chChar)))
		)
		(setq i (+ i 1))
	)
    ;(princ strPost) (princ "<<<<<<<<strPost\n") (princ strPre) (princ "<<<<<<<<strPre\n")
	(if (= bGotThePlusSign 1)
		(progn
			(if (and (= (IsStrNumeric  strPre) T) (= (IsStrNumeric  strPost) T))
				(setq ret (list (atof strPre) (atof strPost)))
				(setq ret nil)
			)
		)
		(progn
			(setq ret nil)
		)
	)
	(setq ret ret); Return
)
(defun ConvStnToChainage (strArg fInterval /  retList retChainage)
	(setq retList (IsStrStation strArg))
	(setq retChainage nil)
	(if (= retList nil)
	   (alert (strcat "ERROR: Bad Param In SubR FindChainage = " strArg))
	   (setq retChainage (+ (* (car retList) fInterval) (cadr retList)))
	)
	(setq retChainage retChainage)
)
(defun FindMinFrList (listParam / i iLoopLim fMin)
	(setq i 0 iLoopLim (length listParam) fMin (nth 0 listParam))
	(while (< i iLoopLim)
		(if (> fMin (nth i listParam)) (setq fMin (nth i listParam)))
		(setq i (+ i 1))
	)
	(setq fMin fMin)
)
(defun FindMaxFrList (listParam / i iLoopLim fMax)
	(setq i 0 iLoopLim (length listParam) fMax (nth 0 listParam))
	(while (< i iLoopLim)
		(if (< fMax (nth i listParam)) (setq fMax (nth i listParam)))
		(setq i (+ i 1))
	)
	(setq fMax fMax)
)
(defun SubstValInList (listParam iIndex voidVal / i iLoopLim retList)
    (setq i 0 iLoopLim (length listParam) retList (list ()))
    (while (< i iLoopLim)
        (if (= i iIndex)
            (setq retList (append retList (list voidVal)))
            (setq retList (append retList (list (nth i listParam))))
        )
        (setq i (+ i 1))
    )
    (setq retList (cdr retList));Return
)
;;
;;AUtil02.Lsp
;;Graphic Utility File
;;

(defun D2R (fAng) (* fAng (/ pi 180.0)))
(defun R2D (fAng) (* (/ 180.0  pi) fAng))
(defun POINT (pt strLyr) (entmake (list (cons 0 "POINT") (cons 10 pt) (cons 8 strLyr))))
(defun LINE (ptStart ptEnd strLyr) (entmake (list (cons 0 "LINE") (cons 10 ptStart) (cons 11 ptEnd) (cons 8 strLyr))))
(defun TEXTLEFT (ptStart str fAngDeg fSize strLyr) (entmake (list (cons 0 "TEXT") (cons 7 (getvar "textstyle")) (cons 1 str)  (cons 10 ptStart) (cons 67 0) (cons 50 (D2R fAngDeg)) (cons 40 fSize) (cons 8 strLyr))))
(defun TEXTMID (ptStart str fAngDeg fSize strLyr) (entmake (list (cons 0 "TEXT") (cons 7 (getvar "textstyle")) (cons 1 str) (cons 71 0) (cons 72 4) (cons 73 0) (cons 11 ptStart) (cons 10 ptStart) (cons 67 0) (cons 50 (D2R fAngDeg)) (cons 40 fSize) (cons 8 strLyr))))
(defun TEXTRIGHT (ptStart str fAngDeg fSize strLyr) (entmake (list (cons 0 "TEXT") (cons 7 (getvar "textstyle"))  (cons 1 str) (cons 71 0) (cons 72 2) (cons 73 0) (cons 11 ptStart) (cons 10 ptStart) (cons 67 0) (cons 50 (D2R fAngDeg)) (cons 40 fSize) (cons 8 strLyr))))
(defun BLOCK (strBlkName ptIns fX fY fRot strLyr / strPreLyr bReturn )
  (setq bReturn 0)
  (if (and (/= strBlkName nil) (/= (tblsearch "BLOCK" strBlkName) nil))
    (progn
      ; Insert Built-in Block
      (entmake (list (cons 0 "INSERT") (cons 8 strLyr) (cons 2 strBlkName) (cons 10 ptIns) (cons 50 (D2R fRot)) (cons 41 fX) (cons 42 fY) (cons 43 1)))
      (setq bReturn 1)
    )
    (progn ; Try to Insert DWG File
      (setq strBlkName (findfile strBlkName))
      (if (= strBlkName nil)
		(setq bReturn 0)
		(progn
		  ;;Insert Dwg File
		  (setq strPreLyr (getvar "CLAYER"))
		  (command "layer" "s" strLyr "" "insert" strBlkName ptIns fX fY fRot "layer" "s" strPreLyr "")
		  (setq bReturn 1)
		)
      )
    )
  );if
  (if (= bReturn 0) (setq bReturn nil) (setq bReturn 1));; Return Statement
)
(defun CreateLayer (listOfLyrNameStr / strPrevLyr i iLoopLim iCmdEcho)
	(setq i 0 iLoopLim (length listOfLyrNameStr) strPrevLyr (getvar "clayer") iCmdEcho (getvar "cmdecho"))
	(setvar "cmdecho" 0)
	(while (< i iLoopLim)
		(if (= (tblsearch "LAYER" (nth i listOfLyrNameStr)) nil)
			(command "layer" "m" (nth i listOfLyrNameStr) "c" (+ i 1) "" ""s)
		)
		(setq i (+ i 1))
	)
	(if (> i 0) (command "layer" "s" strPrevLyr ""))
	(setvar "cmdecho" iCmdEcho)
	(princ)
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;XData Related General func;;;;;;;;;;;;;;;;;;;;;;;START;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq gStrAppNameMain "ATANU_BANIK" gStrAppNameSub "ATANU_BANIK_DATA")
(defun XDataSetup()
	(if (= (tblsearch "appid" gStrAppNameMain) nil)
	  (if (=  (regapp gStrAppNameMain) nil)
		  (princ "\nInternal Error: failed to register XD");
	  )
	)
	(if (= (tblsearch "appid" gStrAppNameSub) nil)
	  (if (=  (regapp gStrAppNameSub) nil)
		  (princ "\nInternal Error: failed to register XD");
	  )
	)
)
(defun AttatchXData(EName strDataMain strDataSub / listXData listEntData)
	(if (= (tblsearch "appid" gStrAppNameMain) nil)
		(XDataSetup)
	)
	(setq listEntData (entget EName)
		  listXData (list (list -3 (list gStrAppNameMain (cons 1000 strDataMain))))
		  listEntData (append listEntData listXData)
	)
	(entmod listEntData)
	(setq listEntData (entget EName)
		  listXData (list (list -3 (list gStrAppNameSub (cons 1000 strDataSub))))
		  listEntData (append listEntData listXData)
	)
	(entmod listEntData)
)
(defun FetchXData(EName / listEntData listToRet i iLim)
	(setq listEntData (entget EName (list gStrAppNameMain gStrAppNameSub))
		  listEntData (assoc -3 listEntData)
		  listToRet (list nil)
	)
	(if(/= listEntData nil)
		(progn
			(setq listEntData (cdr listEntData) i 0 iLim (length listEntData))
			(while (< i iLim)
				(if (or (= (strcase gStrAppNameMain) (car (nth i listEntData))) (= (strcase gStrAppNameSub) (car (nth i listEntData))))
					(setq listToRet (append listToRet (list (cdr (cadr (nth i listEntData))))))
				)
				(setq i (+ i 1))
			)
		)
	)
	(setq listToRet (reverse (cdr listToRet)));Return
)
(defun UpdAnnTxt(iAnnTypeCode fValueToAdd / GetNativeEntitySS UpdateEntities strXDataMain strXDataSub)
	(defun GetNativeEntitySS(strPrompt strEntType strXDataMain strXDataSub / GetEntType i iLim iFilteredOut ssFiltered EName listXData)
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		(defun GetEntType(EName) (cdr (assoc 0 (entget EName))))
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		(princ strPrompt)
		(setq sset01 (ssget)) 
		(setq ssFiltered (ssadd)) 
		(if(/= sset01 nil) 
			(progn
				(setq i 0 iLim (sslength sset01) iFilteredOut 0)
				(while (< i iLim)
					(setq EName (ssname sset01 i))
					(if (= (strcase (GetEntType EName)) strEntType)
						(progn
							;Chk for XData presence..if true then add to sset 
							(setq listXData (FetchXData EName))
							(if (/= listXData nil)
								(progn
									(if (and (= (length listXData) 2) (= strXDataMain (nth 0 listXData)) (wcmatch (nth 1 listXData) strXDataSub)) ;;;;;;;;;(= strXDataSub (nth 1 listXData))
										(setq ssFiltered (ssadd EName ssFiltered));;Add to new SS
										(setq iFilteredOut (+ iFilteredOut 1))
									)
								)
							)
						)
						(progn
							(setq iFilteredOut (+ iFilteredOut 1))
						)
					)
					(setq i (+ i 1))
				);while
				(princ (strcat "\n" (itoa iFilteredOut)  " No of entities filtered out...\nTotal " (itoa (sslength ssFiltered)) " No of entities found"))
			)
		)
		(if(> (sslength ssFiltered) 0)
			(setq ssFiltered ssFiltered);Return
			(setq ssFiltered nil);Return
		)
	)
	(defun UpdateEntities(strXDataMain strXDataSub ValueToAdd / sset i iLim listEnt strTxt)
		(setq sset (GetNativeEntitySS "\nSelect entities to modify :" "TEXT" strXDataMain strXDataSub))
		(if (/=  sset nil)
			(progn
				(setq i 0 iLim (sslength sset))
				(while (< i iLim)
					(setq listEnt (entget (ssname sset i))
						  strTxt (cdr (assoc 1 listEnt))
						  strTxt (rtos (+ (atof strTxt) ValueToAdd))
						  listEnt (subst (cons 1 strTxt) (assoc 1 listEnt) listEnt);;Update entity list 
					)
					(entmod listEnt) ;;Update entity
					(setq i (+ i 1))
				)
			)
		)
		(setq sset sset);;Return
	)
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	(setq strXDataMain "CSDData");;Extended data .........
	(cond 
		((= iAnnTypeCode 0) (setq strXDataSub "ELEV"))
		(T)
	)
	(if(/= iAnnTypeCode 0)
		(princ "ERROR: Abnormal parameter passed!!! Contact developer\n")
		(UpdateEntities strXDataMain strXDataSub fValueToAdd)
	)
	(princ)
)
(defun POLYLINE (listPts  bIsClose strLyr / iCMDECHO i iLoopLim strCurlyr)
    (setq strCurlyr (ChangeCurrentLayer strLyr) iCMDECHO (getvar "cmdecho")) (setvar "cmdecho" 0)
    (setq i 0 iLoopLim (length listPts))
    (command "pline")
    (while (< i iLoopLim) (command (nth  i listPts)) (setq i (+ i 1)))
    (if (= bIsClose T) (command "C") (command "")) (setvar "cmdecho" iCMDECHO)
	(ChangeCurrentLayer strCurlyr)
    (entlast) ;Return
)
(defun C:XD(/ EName) (setq EName (car (entsel))) (FetchXData EName))
(defun ChangeCurrentLayer(strLyrNew / strLyrCur iCMDECHO)
    (setq strLyrCur (getvar "clayer"))
    (if (and (= (IsLayerReadOnly strLyrNew) T) (/= (strcase (getvar "clayer")) (strcase strLyrNew)))
        (progn
            (setq iCMDECHO (getvar "cmdecho")) (setvar "cmdecho" 0) 
            (if(= (tblsearch "LAYER" strLyrNew) nil)
				(command "layer" "m" strLyrNew "")
            )
            (command "layer" "s" strLyrNew "")
			(setvar "cmdecho" iCMDECHO)
        );progn
    )
    (setq strLyrCur strLyrCur);Return
)
(defun IsLayerReadOnly(strLyr / listLyrDet iCMDECHO retFlag)
    (setq listLyrDet (tblsearch "LAYER" strLyr) retFlag nil)
    (if (= nil listLyrDet)
        (progn
            (setq iCMDECHO (getvar "cmdecho")) (setvar "cmdecho" 0) 
            (if(= (tblsearch "LAYER" strLyrNew) nil)
				(command "layer" "m" strLyrNew "")
            )
			(setvar "cmdecho" iCMDECHO)
			(setq retFlag T)
        )
        (progn (setq retFlag T))
    )
    (setq retFlag retFlag);Return
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun FormPlVertexList(listVals / i iLim listRet listPoint)
	(setq i 1 iLim (length listVals) listRet (list ()))
	(while (< i iLim)
		(setq listPoint (list (nth (- i 1) listVals) (nth (+ i 0) listVals))
	          listRet (append listRet (list listPoint))
			  i (+ i 2)
		)
	)
	(setq listRet (cdr listRet))
)
(defun C:EA()(command "erase" "all" "") (princ))
(princ)
